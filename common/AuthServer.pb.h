// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AuthServer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_AuthServer_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_AuthServer_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_AuthServer_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_AuthServer_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_AuthServer_2eproto;
class authUserRequest;
struct authUserRequestDefaultTypeInternal;
extern authUserRequestDefaultTypeInternal _authUserRequest_default_instance_;
class authUserResponse;
struct authUserResponseDefaultTypeInternal;
extern authUserResponseDefaultTypeInternal _authUserResponse_default_instance_;
class getSubjectRequest;
struct getSubjectRequestDefaultTypeInternal;
extern getSubjectRequestDefaultTypeInternal _getSubjectRequest_default_instance_;
class getSubjectResponse;
struct getSubjectResponseDefaultTypeInternal;
extern getSubjectResponseDefaultTypeInternal _getSubjectResponse_default_instance_;
class registerUserRequest;
struct registerUserRequestDefaultTypeInternal;
extern registerUserRequestDefaultTypeInternal _registerUserRequest_default_instance_;
class registerUserResponse;
struct registerUserResponseDefaultTypeInternal;
extern registerUserResponseDefaultTypeInternal _registerUserResponse_default_instance_;
class verifyJWTRequest;
struct verifyJWTRequestDefaultTypeInternal;
extern verifyJWTRequestDefaultTypeInternal _verifyJWTRequest_default_instance_;
class verifyJWTResponse;
struct verifyJWTResponseDefaultTypeInternal;
extern verifyJWTResponseDefaultTypeInternal _verifyJWTResponse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template <>
::authUserRequest* Arena::CreateMaybeMessage<::authUserRequest>(Arena*);
template <>
::authUserResponse* Arena::CreateMaybeMessage<::authUserResponse>(Arena*);
template <>
::getSubjectRequest* Arena::CreateMaybeMessage<::getSubjectRequest>(Arena*);
template <>
::getSubjectResponse* Arena::CreateMaybeMessage<::getSubjectResponse>(Arena*);
template <>
::registerUserRequest* Arena::CreateMaybeMessage<::registerUserRequest>(Arena*);
template <>
::registerUserResponse* Arena::CreateMaybeMessage<::registerUserResponse>(Arena*);
template <>
::verifyJWTRequest* Arena::CreateMaybeMessage<::verifyJWTRequest>(Arena*);
template <>
::verifyJWTResponse* Arena::CreateMaybeMessage<::verifyJWTResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE


// ===================================================================


// -------------------------------------------------------------------

class authUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authUserRequest) */ {
 public:
  inline authUserRequest() : authUserRequest(nullptr) {}
  ~authUserRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR authUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  authUserRequest(const authUserRequest& from);
  authUserRequest(authUserRequest&& from) noexcept
    : authUserRequest() {
    *this = ::std::move(from);
  }

  inline authUserRequest& operator=(const authUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline authUserRequest& operator=(authUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const authUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const authUserRequest* internal_default_instance() {
    return reinterpret_cast<const authUserRequest*>(
               &_authUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(authUserRequest& a, authUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(authUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(authUserRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  authUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<authUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const authUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const authUserRequest& from) {
    authUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(authUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "authUserRequest";
  }
  protected:
  explicit authUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username() ;
  const std::string& username() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* ptr);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* ptr);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:authUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AuthServer_2eproto;
};// -------------------------------------------------------------------

class authUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authUserResponse) */ {
 public:
  inline authUserResponse() : authUserResponse(nullptr) {}
  ~authUserResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR authUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  authUserResponse(const authUserResponse& from);
  authUserResponse(authUserResponse&& from) noexcept
    : authUserResponse() {
    *this = ::std::move(from);
  }

  inline authUserResponse& operator=(const authUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline authUserResponse& operator=(authUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const authUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const authUserResponse* internal_default_instance() {
    return reinterpret_cast<const authUserResponse*>(
               &_authUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(authUserResponse& a, authUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(authUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(authUserResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  authUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<authUserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const authUserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const authUserResponse& from) {
    authUserResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(authUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "authUserResponse";
  }
  protected:
  explicit authUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* ptr);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // string error = 2;
  void clear_error() ;
  const std::string& error() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* ptr);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:authUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AuthServer_2eproto;
};// -------------------------------------------------------------------

class registerUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:registerUserRequest) */ {
 public:
  inline registerUserRequest() : registerUserRequest(nullptr) {}
  ~registerUserRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR registerUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  registerUserRequest(const registerUserRequest& from);
  registerUserRequest(registerUserRequest&& from) noexcept
    : registerUserRequest() {
    *this = ::std::move(from);
  }

  inline registerUserRequest& operator=(const registerUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline registerUserRequest& operator=(registerUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const registerUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const registerUserRequest* internal_default_instance() {
    return reinterpret_cast<const registerUserRequest*>(
               &_registerUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(registerUserRequest& a, registerUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(registerUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(registerUserRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  registerUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<registerUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const registerUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const registerUserRequest& from) {
    registerUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(registerUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "registerUserRequest";
  }
  protected:
  explicit registerUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username() ;
  const std::string& username() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* ptr);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* ptr);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:registerUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AuthServer_2eproto;
};// -------------------------------------------------------------------

class registerUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:registerUserResponse) */ {
 public:
  inline registerUserResponse() : registerUserResponse(nullptr) {}
  ~registerUserResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR registerUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  registerUserResponse(const registerUserResponse& from);
  registerUserResponse(registerUserResponse&& from) noexcept
    : registerUserResponse() {
    *this = ::std::move(from);
  }

  inline registerUserResponse& operator=(const registerUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline registerUserResponse& operator=(registerUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const registerUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const registerUserResponse* internal_default_instance() {
    return reinterpret_cast<const registerUserResponse*>(
               &_registerUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(registerUserResponse& a, registerUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(registerUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(registerUserResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  registerUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<registerUserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const registerUserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const registerUserResponse& from) {
    registerUserResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(registerUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "registerUserResponse";
  }
  protected:
  explicit registerUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:registerUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AuthServer_2eproto;
};// -------------------------------------------------------------------

class getSubjectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:getSubjectRequest) */ {
 public:
  inline getSubjectRequest() : getSubjectRequest(nullptr) {}
  ~getSubjectRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getSubjectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getSubjectRequest(const getSubjectRequest& from);
  getSubjectRequest(getSubjectRequest&& from) noexcept
    : getSubjectRequest() {
    *this = ::std::move(from);
  }

  inline getSubjectRequest& operator=(const getSubjectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline getSubjectRequest& operator=(getSubjectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getSubjectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const getSubjectRequest* internal_default_instance() {
    return reinterpret_cast<const getSubjectRequest*>(
               &_getSubjectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(getSubjectRequest& a, getSubjectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(getSubjectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getSubjectRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getSubjectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getSubjectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getSubjectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getSubjectRequest& from) {
    getSubjectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getSubjectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "getSubjectRequest";
  }
  protected:
  explicit getSubjectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* ptr);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // @@protoc_insertion_point(class_scope:getSubjectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AuthServer_2eproto;
};// -------------------------------------------------------------------

class getSubjectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:getSubjectResponse) */ {
 public:
  inline getSubjectResponse() : getSubjectResponse(nullptr) {}
  ~getSubjectResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getSubjectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getSubjectResponse(const getSubjectResponse& from);
  getSubjectResponse(getSubjectResponse&& from) noexcept
    : getSubjectResponse() {
    *this = ::std::move(from);
  }

  inline getSubjectResponse& operator=(const getSubjectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline getSubjectResponse& operator=(getSubjectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getSubjectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const getSubjectResponse* internal_default_instance() {
    return reinterpret_cast<const getSubjectResponse*>(
               &_getSubjectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(getSubjectResponse& a, getSubjectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(getSubjectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getSubjectResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getSubjectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getSubjectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getSubjectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getSubjectResponse& from) {
    getSubjectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getSubjectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "getSubjectResponse";
  }
  protected:
  explicit getSubjectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string subject = 1;
  void clear_subject() ;
  const std::string& subject() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* ptr);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // string error = 2;
  void clear_error() ;
  const std::string& error() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* ptr);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:getSubjectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AuthServer_2eproto;
};// -------------------------------------------------------------------

class verifyJWTRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:verifyJWTRequest) */ {
 public:
  inline verifyJWTRequest() : verifyJWTRequest(nullptr) {}
  ~verifyJWTRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR verifyJWTRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  verifyJWTRequest(const verifyJWTRequest& from);
  verifyJWTRequest(verifyJWTRequest&& from) noexcept
    : verifyJWTRequest() {
    *this = ::std::move(from);
  }

  inline verifyJWTRequest& operator=(const verifyJWTRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline verifyJWTRequest& operator=(verifyJWTRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const verifyJWTRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const verifyJWTRequest* internal_default_instance() {
    return reinterpret_cast<const verifyJWTRequest*>(
               &_verifyJWTRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(verifyJWTRequest& a, verifyJWTRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(verifyJWTRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(verifyJWTRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  verifyJWTRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<verifyJWTRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const verifyJWTRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const verifyJWTRequest& from) {
    verifyJWTRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(verifyJWTRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "verifyJWTRequest";
  }
  protected:
  explicit verifyJWTRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* ptr);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // @@protoc_insertion_point(class_scope:verifyJWTRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AuthServer_2eproto;
};// -------------------------------------------------------------------

class verifyJWTResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:verifyJWTResponse) */ {
 public:
  inline verifyJWTResponse() : verifyJWTResponse(nullptr) {}
  ~verifyJWTResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR verifyJWTResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  verifyJWTResponse(const verifyJWTResponse& from);
  verifyJWTResponse(verifyJWTResponse&& from) noexcept
    : verifyJWTResponse() {
    *this = ::std::move(from);
  }

  inline verifyJWTResponse& operator=(const verifyJWTResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline verifyJWTResponse& operator=(verifyJWTResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const verifyJWTResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const verifyJWTResponse* internal_default_instance() {
    return reinterpret_cast<const verifyJWTResponse*>(
               &_verifyJWTResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(verifyJWTResponse& a, verifyJWTResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(verifyJWTResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(verifyJWTResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  verifyJWTResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<verifyJWTResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const verifyJWTResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const verifyJWTResponse& from) {
    verifyJWTResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(verifyJWTResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "verifyJWTResponse";
  }
  protected:
  explicit verifyJWTResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kVerifiedFieldNumber = 1,
  };
  // string error = 2;
  void clear_error() ;
  const std::string& error() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* ptr);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // bool verified = 1;
  void clear_verified() ;
  bool verified() const;
  void set_verified(bool value);

  private:
  bool _internal_verified() const;
  void _internal_set_verified(bool value);

  public:
  // @@protoc_insertion_point(class_scope:verifyJWTResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    bool verified_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_AuthServer_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// authUserRequest

// string username = 1;
inline void authUserRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& authUserRequest::username() const {
  // @@protoc_insertion_point(field_get:authUserRequest.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void authUserRequest::set_username(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authUserRequest.username)
}
inline std::string* authUserRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:authUserRequest.username)
  return _s;
}
inline const std::string& authUserRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void authUserRequest::_internal_set_username(const std::string& value) {
  ;


  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* authUserRequest::_internal_mutable_username() {
  ;
  return _impl_.username_.Mutable( GetArenaForAllocation());
}
inline std::string* authUserRequest::release_username() {
  // @@protoc_insertion_point(field_release:authUserRequest.username)
  return _impl_.username_.Release();
}
inline void authUserRequest::set_allocated_username(std::string* value) {
  _impl_.username_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authUserRequest.username)
}

// string password = 2;
inline void authUserRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& authUserRequest::password() const {
  // @@protoc_insertion_point(field_get:authUserRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void authUserRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authUserRequest.password)
}
inline std::string* authUserRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:authUserRequest.password)
  return _s;
}
inline const std::string& authUserRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void authUserRequest::_internal_set_password(const std::string& value) {
  ;


  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* authUserRequest::_internal_mutable_password() {
  ;
  return _impl_.password_.Mutable( GetArenaForAllocation());
}
inline std::string* authUserRequest::release_password() {
  // @@protoc_insertion_point(field_release:authUserRequest.password)
  return _impl_.password_.Release();
}
inline void authUserRequest::set_allocated_password(std::string* value) {
  _impl_.password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authUserRequest.password)
}

// -------------------------------------------------------------------

// authUserResponse

// string token = 1;
inline void authUserResponse::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& authUserResponse::token() const {
  // @@protoc_insertion_point(field_get:authUserResponse.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void authUserResponse::set_token(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authUserResponse.token)
}
inline std::string* authUserResponse::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:authUserResponse.token)
  return _s;
}
inline const std::string& authUserResponse::_internal_token() const {
  return _impl_.token_.Get();
}
inline void authUserResponse::_internal_set_token(const std::string& value) {
  ;


  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* authUserResponse::_internal_mutable_token() {
  ;
  return _impl_.token_.Mutable( GetArenaForAllocation());
}
inline std::string* authUserResponse::release_token() {
  // @@protoc_insertion_point(field_release:authUserResponse.token)
  return _impl_.token_.Release();
}
inline void authUserResponse::set_allocated_token(std::string* value) {
  _impl_.token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_.IsDefault()) {
          _impl_.token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authUserResponse.token)
}

// string error = 2;
inline void authUserResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& authUserResponse::error() const {
  // @@protoc_insertion_point(field_get:authUserResponse.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void authUserResponse::set_error(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authUserResponse.error)
}
inline std::string* authUserResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:authUserResponse.error)
  return _s;
}
inline const std::string& authUserResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void authUserResponse::_internal_set_error(const std::string& value) {
  ;


  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* authUserResponse::_internal_mutable_error() {
  ;
  return _impl_.error_.Mutable( GetArenaForAllocation());
}
inline std::string* authUserResponse::release_error() {
  // @@protoc_insertion_point(field_release:authUserResponse.error)
  return _impl_.error_.Release();
}
inline void authUserResponse::set_allocated_error(std::string* value) {
  _impl_.error_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authUserResponse.error)
}

// -------------------------------------------------------------------

// registerUserRequest

// string username = 1;
inline void registerUserRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& registerUserRequest::username() const {
  // @@protoc_insertion_point(field_get:registerUserRequest.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void registerUserRequest::set_username(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:registerUserRequest.username)
}
inline std::string* registerUserRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:registerUserRequest.username)
  return _s;
}
inline const std::string& registerUserRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void registerUserRequest::_internal_set_username(const std::string& value) {
  ;


  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* registerUserRequest::_internal_mutable_username() {
  ;
  return _impl_.username_.Mutable( GetArenaForAllocation());
}
inline std::string* registerUserRequest::release_username() {
  // @@protoc_insertion_point(field_release:registerUserRequest.username)
  return _impl_.username_.Release();
}
inline void registerUserRequest::set_allocated_username(std::string* value) {
  _impl_.username_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:registerUserRequest.username)
}

// string password = 2;
inline void registerUserRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& registerUserRequest::password() const {
  // @@protoc_insertion_point(field_get:registerUserRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void registerUserRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:registerUserRequest.password)
}
inline std::string* registerUserRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:registerUserRequest.password)
  return _s;
}
inline const std::string& registerUserRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void registerUserRequest::_internal_set_password(const std::string& value) {
  ;


  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* registerUserRequest::_internal_mutable_password() {
  ;
  return _impl_.password_.Mutable( GetArenaForAllocation());
}
inline std::string* registerUserRequest::release_password() {
  // @@protoc_insertion_point(field_release:registerUserRequest.password)
  return _impl_.password_.Release();
}
inline void registerUserRequest::set_allocated_password(std::string* value) {
  _impl_.password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:registerUserRequest.password)
}

// -------------------------------------------------------------------

// registerUserResponse

// bool success = 1;
inline void registerUserResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool registerUserResponse::success() const {
  // @@protoc_insertion_point(field_get:registerUserResponse.success)
  return _internal_success();
}
inline void registerUserResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:registerUserResponse.success)
}
inline bool registerUserResponse::_internal_success() const {
  return _impl_.success_;
}
inline void registerUserResponse::_internal_set_success(bool value) {
  ;
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// getSubjectRequest

// string token = 1;
inline void getSubjectRequest::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& getSubjectRequest::token() const {
  // @@protoc_insertion_point(field_get:getSubjectRequest.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void getSubjectRequest::set_token(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:getSubjectRequest.token)
}
inline std::string* getSubjectRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:getSubjectRequest.token)
  return _s;
}
inline const std::string& getSubjectRequest::_internal_token() const {
  return _impl_.token_.Get();
}
inline void getSubjectRequest::_internal_set_token(const std::string& value) {
  ;


  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* getSubjectRequest::_internal_mutable_token() {
  ;
  return _impl_.token_.Mutable( GetArenaForAllocation());
}
inline std::string* getSubjectRequest::release_token() {
  // @@protoc_insertion_point(field_release:getSubjectRequest.token)
  return _impl_.token_.Release();
}
inline void getSubjectRequest::set_allocated_token(std::string* value) {
  _impl_.token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_.IsDefault()) {
          _impl_.token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:getSubjectRequest.token)
}

// -------------------------------------------------------------------

// getSubjectResponse

// string subject = 1;
inline void getSubjectResponse::clear_subject() {
  _impl_.subject_.ClearToEmpty();
}
inline const std::string& getSubjectResponse::subject() const {
  // @@protoc_insertion_point(field_get:getSubjectResponse.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void getSubjectResponse::set_subject(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:getSubjectResponse.subject)
}
inline std::string* getSubjectResponse::mutable_subject() {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:getSubjectResponse.subject)
  return _s;
}
inline const std::string& getSubjectResponse::_internal_subject() const {
  return _impl_.subject_.Get();
}
inline void getSubjectResponse::_internal_set_subject(const std::string& value) {
  ;


  _impl_.subject_.Set(value, GetArenaForAllocation());
}
inline std::string* getSubjectResponse::_internal_mutable_subject() {
  ;
  return _impl_.subject_.Mutable( GetArenaForAllocation());
}
inline std::string* getSubjectResponse::release_subject() {
  // @@protoc_insertion_point(field_release:getSubjectResponse.subject)
  return _impl_.subject_.Release();
}
inline void getSubjectResponse::set_allocated_subject(std::string* value) {
  _impl_.subject_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_.IsDefault()) {
          _impl_.subject_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:getSubjectResponse.subject)
}

// string error = 2;
inline void getSubjectResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& getSubjectResponse::error() const {
  // @@protoc_insertion_point(field_get:getSubjectResponse.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void getSubjectResponse::set_error(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:getSubjectResponse.error)
}
inline std::string* getSubjectResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:getSubjectResponse.error)
  return _s;
}
inline const std::string& getSubjectResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void getSubjectResponse::_internal_set_error(const std::string& value) {
  ;


  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* getSubjectResponse::_internal_mutable_error() {
  ;
  return _impl_.error_.Mutable( GetArenaForAllocation());
}
inline std::string* getSubjectResponse::release_error() {
  // @@protoc_insertion_point(field_release:getSubjectResponse.error)
  return _impl_.error_.Release();
}
inline void getSubjectResponse::set_allocated_error(std::string* value) {
  _impl_.error_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:getSubjectResponse.error)
}

// -------------------------------------------------------------------

// verifyJWTRequest

// string token = 1;
inline void verifyJWTRequest::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& verifyJWTRequest::token() const {
  // @@protoc_insertion_point(field_get:verifyJWTRequest.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void verifyJWTRequest::set_token(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:verifyJWTRequest.token)
}
inline std::string* verifyJWTRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:verifyJWTRequest.token)
  return _s;
}
inline const std::string& verifyJWTRequest::_internal_token() const {
  return _impl_.token_.Get();
}
inline void verifyJWTRequest::_internal_set_token(const std::string& value) {
  ;


  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* verifyJWTRequest::_internal_mutable_token() {
  ;
  return _impl_.token_.Mutable( GetArenaForAllocation());
}
inline std::string* verifyJWTRequest::release_token() {
  // @@protoc_insertion_point(field_release:verifyJWTRequest.token)
  return _impl_.token_.Release();
}
inline void verifyJWTRequest::set_allocated_token(std::string* value) {
  _impl_.token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_.IsDefault()) {
          _impl_.token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:verifyJWTRequest.token)
}

// -------------------------------------------------------------------

// verifyJWTResponse

// bool verified = 1;
inline void verifyJWTResponse::clear_verified() {
  _impl_.verified_ = false;
}
inline bool verifyJWTResponse::verified() const {
  // @@protoc_insertion_point(field_get:verifyJWTResponse.verified)
  return _internal_verified();
}
inline void verifyJWTResponse::set_verified(bool value) {
  _internal_set_verified(value);
  // @@protoc_insertion_point(field_set:verifyJWTResponse.verified)
}
inline bool verifyJWTResponse::_internal_verified() const {
  return _impl_.verified_;
}
inline void verifyJWTResponse::_internal_set_verified(bool value) {
  ;
  _impl_.verified_ = value;
}

// string error = 2;
inline void verifyJWTResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& verifyJWTResponse::error() const {
  // @@protoc_insertion_point(field_get:verifyJWTResponse.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void verifyJWTResponse::set_error(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:verifyJWTResponse.error)
}
inline std::string* verifyJWTResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:verifyJWTResponse.error)
  return _s;
}
inline const std::string& verifyJWTResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void verifyJWTResponse::_internal_set_error(const std::string& value) {
  ;


  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* verifyJWTResponse::_internal_mutable_error() {
  ;
  return _impl_.error_.Mutable( GetArenaForAllocation());
}
inline std::string* verifyJWTResponse::release_error() {
  // @@protoc_insertion_point(field_release:verifyJWTResponse.error)
  return _impl_.error_.Release();
}
inline void verifyJWTResponse::set_allocated_error(std::string* value) {
  _impl_.error_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:verifyJWTResponse.error)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_AuthServer_2eproto_2epb_2eh
